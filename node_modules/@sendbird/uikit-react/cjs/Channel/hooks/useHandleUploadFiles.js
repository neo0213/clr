'use strict';

var _tslib = require('../../chunks/bundle-QH7iLrPR.js');
var React = require('react');
var useSendbirdStateContext = require('../../useSendbirdStateContext.js');
var index = require('../../chunks/bundle-F--qTOLe.js');
var hooks_useModal = require('../../hooks/useModal.js');
require('../../chunks/bundle-0MHADZvF.js');
var ui_Button = require('../../ui/Button.js');
var LocalizationContext = require('../../chunks/bundle-ZurhBjw4.js');
var ui_Modal = require('../../chunks/bundle-JragPpHy.js');
var pxToNumber = require('../../chunks/bundle-MeuNh9Q9.js');
require('../../withSendbird.js');
require('../../utils/message/getOutgoingMessageState.js');
require('../../chunks/bundle-AQhLE-Ci.js');
require('../../chunks/bundle-Pe-j2f1D.js');
require('react-dom');
require('../../chunks/bundle-v8bBiJ_c.js');
require('../../chunks/bundle-cV7uGK08.js');
require('../../chunks/bundle-vWUmeH2R.js');
require('../../ui/IconButton.js');
require('../../ui/Icon.js');

var compressImage = function (_a) {
    var imageFile = _a.imageFile, compressionRate = _a.compressionRate, resizingWidth = _a.resizingWidth, resizingHeight = _a.resizingHeight;
    var image = document.createElement('img');
    return new Promise(function (resolve, reject) {
        image.src = URL.createObjectURL(imageFile);
        image.onerror = reject;
        image.onload = function () {
            URL.revokeObjectURL(image.src);
            var canvas = document.createElement('canvas');
            var originWidth = image.width;
            var originHeight = image.height;
            var widthRatio = originWidth / (resizingWidth || originWidth);
            var heightRatio = originHeight / (resizingHeight || originHeight);
            var targetResizingWidth = resizingWidth || originWidth;
            var targetResizingHeight = resizingHeight || originHeight;
            // Use the more impactful value, so the original images' ratio won't be broken
            if (widthRatio > heightRatio) {
                targetResizingHeight = originHeight / (resizingWidth ? widthRatio : 1);
            }
            else if (heightRatio > widthRatio) {
                targetResizingWidth = originWidth / (resizingHeight ? heightRatio : 1);
            }
            canvas.width = targetResizingWidth;
            canvas.height = targetResizingHeight;
            var ctx = canvas.getContext('2d');
            if (!ctx) {
                reject(new Error('Failed to get canvas 2d context'));
                return;
            }
            ctx.drawImage(image, 0, 0, targetResizingWidth, targetResizingHeight);
            ctx.canvas.toBlob(function (blob) {
                if (blob) {
                    var file = new File([blob], imageFile.name, { type: imageFile.type });
                    resolve(file);
                }
                else {
                    reject(new Error('Failed to compress image'));
                }
            }, imageFile.type, compressionRate);
        };
    });
};
var compressImages = function (_a) {
    var files = _a.files, logger = _a.logger, imageCompression = _a.imageCompression;
    return _tslib.__awaiter(void 0, void 0, void 0, function () {
        var compressionRate, resizingWidth, resizingHeight, result;
        return _tslib.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    compressionRate = imageCompression.compressionRate;
                    resizingWidth = pxToNumber.pxToNumber(imageCompression.resizingWidth);
                    resizingHeight = pxToNumber.pxToNumber(imageCompression.resizingHeight);
                    result = {
                        failedIndexes: [],
                        compressedFiles: [],
                    };
                    if (!(Array.isArray(files) && files.length > 0)) {
                        logger.warning('utils - compressImages: There are no files.', files);
                        return [2 /*return*/, result];
                    }
                    if (compressionRate < 0 || 1 < compressionRate) {
                        logger.warning('utils - compressImages: The compressionRate is not acceptable.', compressionRate);
                        return [2 /*return*/, result];
                    }
                    return [4 /*yield*/, Promise.all(files
                            .map(function (file, index) { return _tslib.__awaiter(void 0, void 0, void 0, function () {
                            var compressedImage, err_1;
                            return _tslib.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        if (!(file.type === 'image/jpg' || file.type === 'image/png' || file.type === 'image/jpeg')) {
                                            logger.warning('utils - compressImages: The fileType is not compressible.', { file: file, index: index });
                                            result.failedIndexes.push(index);
                                            result.compressedFiles.push(file);
                                            return [2 /*return*/];
                                        }
                                        _a.label = 1;
                                    case 1:
                                        _a.trys.push([1, 3, , 4]);
                                        return [4 /*yield*/, compressImage({
                                                imageFile: file,
                                                compressionRate: compressionRate,
                                                resizingWidth: resizingWidth,
                                                resizingHeight: resizingHeight,
                                            })];
                                    case 2:
                                        compressedImage = _a.sent();
                                        result.compressedFiles.push(compressedImage);
                                        return [3 /*break*/, 4];
                                    case 3:
                                        err_1 = _a.sent();
                                        result.failedIndexes.push(index);
                                        logger.warning('utils - compressImages: Failed to compress image file', { err: err_1 });
                                        return [3 /*break*/, 4];
                                    case 4: return [2 /*return*/];
                                }
                            });
                        }); }))];
                case 1:
                    _b.sent();
                    logger.info('utils - compressImages: Finished compressing images', result);
                    return [2 /*return*/, result];
            }
        });
    });
};

var useHandleUploadFiles = function (_a, _b) {
    var sendFileMessage = _a.sendFileMessage, sendMultipleFilesMessage = _a.sendMultipleFilesMessage, quoteMessage = _a.quoteMessage;
    var logger = _b.logger;
    var stringSet = LocalizationContext.useLocalization().stringSet;
    var config = useSendbirdStateContext.useSendbirdStateContext().config;
    var imageCompression = config.imageCompression;
    var uikitUploadSizeLimit = config === null || config === void 0 ? void 0 : config.uikitUploadSizeLimit;
    var uikitMultipleFilesMessageLimit = config === null || config === void 0 ? void 0 : config.uikitMultipleFilesMessageLimit;
    var openModal = hooks_useModal.useGlobalModalContext().openModal;
    var handleUploadFiles = React.useCallback(function (files) { return _tslib.__awaiter(void 0, void 0, void 0, function () {
        var ONE_MiB, compressedFiles, sendingFiles, file, imageFiles_1, otherFiles_1;
        return _tslib.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    // Validate Parameters
                    if (!sendFileMessage || !sendMultipleFilesMessage) {
                        logger.warning('Channel|useHandleUploadFiles: required functions are undefined', { sendFileMessage: sendFileMessage, sendMultipleFilesMessage: sendMultipleFilesMessage });
                        return [2 /*return*/];
                    }
                    if (files.length === 0) {
                        logger.warning('Channel|useHandleUploadFiles: given file list is empty.', { files: files });
                        return [2 /*return*/];
                    }
                    if (files.length > uikitMultipleFilesMessageLimit) {
                        logger.info("Channel|useHandleUploadFiles: Cannot upload files more than ".concat(uikitMultipleFilesMessageLimit));
                        openModal({
                            modalProps: {
                                titleText: "Up to ".concat(uikitMultipleFilesMessageLimit, " files can be attached."),
                                hideFooter: true,
                            },
                            childElement: function (_a) {
                                var closeModal = _a.closeModal;
                                return (React.createElement(ui_Modal.ModalFooter, { type: ui_Button.ButtonTypes.PRIMARY, submitText: stringSet.BUTTON__OK, hideCancelButton: true, onCancel: closeModal, onSubmit: closeModal }));
                            },
                        });
                        return [2 /*return*/];
                    }
                    // Validate file sizes
                    if (files.some(function (file) { return file.size > uikitUploadSizeLimit; })) {
                        // The default value of uikitUploadSizeLimit is 26MB
                        logger.info("Channel|useHandleUploadFiles: Cannot upload file size exceeding ".concat(uikitUploadSizeLimit));
                        ONE_MiB = 1024 * 1024;
                        openModal({
                            modalProps: {
                                titleText: "The maximum size per file is ".concat(Math.floor(uikitUploadSizeLimit / ONE_MiB), " MB."),
                                hideFooter: true,
                            },
                            childElement: function (_a) {
                                var closeModal = _a.closeModal;
                                return (React.createElement(ui_Modal.ModalFooter, { type: ui_Button.ButtonTypes.PRIMARY, submitText: stringSet.BUTTON__OK, hideCancelButton: true, onCancel: closeModal, onSubmit: closeModal }));
                            },
                        });
                        return [2 /*return*/];
                    }
                    return [4 /*yield*/, compressImages({
                            files: files,
                            imageCompression: imageCompression,
                            logger: logger,
                        })];
                case 1:
                    compressedFiles = (_a.sent()).compressedFiles;
                    sendingFiles = compressedFiles;
                    // Send File Message
                    if (sendingFiles.length === 1) {
                        logger.info('Channel|useHandleUploadFiles: sending one file.');
                        file = sendingFiles[0];
                        sendFileMessage(file, quoteMessage);
                    }
                    else if (sendingFiles.length > 1) {
                        logger.info('Channel|useHandleUploadFiles: sending multiple files.');
                        imageFiles_1 = [];
                        otherFiles_1 = [];
                        sendingFiles.forEach(function (file) {
                            if (index.isImage(file.type)) {
                                imageFiles_1.push(file);
                            }
                            else {
                                otherFiles_1.push(file);
                            }
                        });
                        return [2 /*return*/, otherFiles_1.reduce(function (previousPromise, item) {
                                return previousPromise.then(function () {
                                    return sendFileMessage(item, quoteMessage);
                                });
                            }, (function () {
                                if (imageFiles_1.length === 0) {
                                    return Promise.resolve();
                                }
                                else if (imageFiles_1.length === 1) {
                                    return sendFileMessage(imageFiles_1[0], quoteMessage);
                                }
                                else {
                                    return sendMultipleFilesMessage(imageFiles_1, quoteMessage);
                                }
                            })())];
                    }
                    return [2 /*return*/];
            }
        });
    }); }, [
        sendFileMessage,
        sendMultipleFilesMessage,
        quoteMessage,
    ]);
    return handleUploadFiles;
};

exports.useHandleUploadFiles = useHandleUploadFiles;
//# sourceMappingURL=useHandleUploadFiles.js.map
