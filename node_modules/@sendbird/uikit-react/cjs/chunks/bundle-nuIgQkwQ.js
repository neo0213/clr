'use strict';

var React = require('react');
var consts = require('./bundle-EVdeXpsD.js');

function useDebounce(callback, delay) {
    var timeoutRef = React.useRef(null);
    React.useEffect(function () {
        // Cleanup the timeout on unmount
        return function () {
            if (timeoutRef.current) {
                clearTimeout(timeoutRef.current);
            }
        };
    }, []);
    function debounceFunction() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (timeoutRef.current) {
            clearTimeout(timeoutRef.current);
        }
        timeoutRef.current = setTimeout(function () {
            callback.apply(void 0, args);
        }, delay);
    }
    return debounceFunction;
}

var DELAY = 500;
function calcScrollBottom(scrollHeight, scrollTop) {
    return scrollHeight - scrollTop;
}
function useHandleOnScrollCallback(_a) {
    var hasMore = _a.hasMore, hasNext = _a.hasNext, onScroll = _a.onScroll, scrollRef = _a.scrollRef, setShowScrollDownButton = _a.setShowScrollDownButton;
    var scrollCb = React.useCallback(function () {
        var element = scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current;
        if (element == null) {
            return;
        }
        var scrollTop = element.scrollTop, scrollHeight = element.scrollHeight, clientHeight = element.clientHeight;
        // https://sendbird.atlassian.net/browse/SBISSUE-11759
        // the edge case where channel is inside a page that already has scroll
        // scrollintoView will move the whole page, which we dont want
        var scrollBottom = calcScrollBottom(scrollHeight, scrollTop);
        // even if there is more to fetch or not,
        // we still have to show the scroll to bottom button
        if (typeof setShowScrollDownButton === 'function') {
            setShowScrollDownButton(scrollHeight > scrollTop + clientHeight + 1);
        }
        if (hasMore && scrollTop < consts.SCROLL_BUFFER) {
            onScroll(function () {
                // sets the scroll position to the bottom of the new messages
                element.scrollTop = element.scrollHeight - scrollBottom;
            });
        }
        if (hasNext) {
            onScroll(function () {
                // sets the scroll position to the top of the new messages
                element.scrollTop = scrollTop - (scrollHeight - element.scrollHeight);
            });
        }
    }, [
        setShowScrollDownButton,
        hasMore,
        onScroll,
        scrollRef,
    ]);
    return useDebounce(scrollCb, DELAY);
}

exports.useDebounce = useDebounce;
exports.useHandleOnScrollCallback = useHandleOnScrollCallback;
//# sourceMappingURL=bundle-nuIgQkwQ.js.map
