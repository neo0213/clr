'use strict';

var React = require('react');
var pubSub_topics = require('./bundle-0wbO-LdY.js');
var utils = require('./bundle-pxBxPT0b.js');
var index = require('./bundle-nGMCZjvM.js');
var utils_message_getOutgoingMessageState = require('../utils/message/getOutgoingMessageState.js');

var getNicknamesMapFromMembers = function (members) {
    if (members === void 0) { members = []; }
    var nicknamesMap = new Map();
    for (var memberIndex = 0; memberIndex < members.length; memberIndex += 1) {
        var _a = members[memberIndex], userId = _a.userId, nickname = _a.nickname;
        nicknamesMap.set(userId, nickname);
    }
    return nicknamesMap;
};
var getParentMessageFrom = function (message) {
    if (!message) {
        return null;
    }
    if (isParentMessage(message)) {
        return message;
    }
    if (isThreadMessage(message)) {
        return (message === null || message === void 0 ? void 0 : message.parentMessage) || null;
    }
    return null;
};
var isParentMessage = function (message) {
    return ((message === null || message === void 0 ? void 0 : message.parentMessage) === null
        && typeof (message === null || message === void 0 ? void 0 : message.parentMessageId) === 'number'
        && !(message === null || message === void 0 ? void 0 : message.parentMessageId));
};
var isThreadMessage = function (message) {
    return ((message === null || message === void 0 ? void 0 : message.parentMessage) !== null
        && typeof (message === null || message === void 0 ? void 0 : message.parentMessageId) === 'number'
        && (message === null || message === void 0 ? void 0 : message.parentMessageId) > 0
        && (message === null || message === void 0 ? void 0 : message.threadInfo) === null);
};
var isAboutSame = function (a, b, px) { return (Math.abs(a - b) <= px); };
var isEmpty = function (val) { return (val === null || val === undefined); };
// Some Ids return string and number inconsistently
// only use to comapre IDs
function compareIds(a, b) {
    if (isEmpty(a) || isEmpty(b)) {
        return false;
    }
    var aString = a.toString();
    var bString = b.toString();
    return aString === bString;
}
var getMessageCreatedAt = function (message) { return index.format(message.createdAt, 'p'); };
var isReadMessage = function (channel, message) { return (utils_message_getOutgoingMessageState.getOutgoingMessageState(channel, message) === utils_message_getOutgoingMessageState.OutgoingMessageStates.READ); };
var isSameGroup = function (message, comparingMessage, currentChannel) {
    var _a, _b, _c, _d;
    if (!(message
        && comparingMessage
        && message.messageType
        && message.messageType !== 'admin'
        && comparingMessage.messageType
        && (comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.messageType) !== 'admin'
        && (message === null || message === void 0 ? void 0 : message.sender)
        && (comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.sender)
        && (message === null || message === void 0 ? void 0 : message.createdAt)
        && (comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.createdAt)
        && ((_a = message === null || message === void 0 ? void 0 : message.sender) === null || _a === void 0 ? void 0 : _a.userId)
        && ((_b = comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.sender) === null || _b === void 0 ? void 0 : _b.userId))) {
        return false;
    }
    return ((message === null || message === void 0 ? void 0 : message.sendingStatus) === (comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.sendingStatus)
        && ((_c = message === null || message === void 0 ? void 0 : message.sender) === null || _c === void 0 ? void 0 : _c.userId) === ((_d = comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.sender) === null || _d === void 0 ? void 0 : _d.userId)
        && getMessageCreatedAt(message) === getMessageCreatedAt(comparingMessage)
        && isReadMessage(currentChannel, message) === isReadMessage(currentChannel, comparingMessage));
};
var compareMessagesForGrouping = function (prevMessage, currMessage, nextMessage, currentChannel, replyType) {
    if (replyType === 'THREAD' && (currMessage === null || currMessage === void 0 ? void 0 : currMessage.threadInfo)) {
        return [false, false];
    }
    var sendingStatus = (currMessage === null || currMessage === void 0 ? void 0 : currMessage.sendingStatus) || '';
    var isAcceptable = sendingStatus !== 'pending' && sendingStatus !== 'failed';
    return [
        isSameGroup(prevMessage, currMessage, currentChannel) && isAcceptable,
        isSameGroup(currMessage, nextMessage, currentChannel) && isAcceptable,
    ];
};
var scrollIntoLast = function (intialTry) {
    if (intialTry === void 0) { intialTry = 0; }
    var MAX_TRIES = 10;
    var currentTry = intialTry;
    if (currentTry > MAX_TRIES) {
        return;
    }
    try {
        var scrollDOM = document.querySelector('.sendbird-thread-ui--scroll');
        // eslint-disable-next-line no-multi-assign
        scrollDOM.scrollTop = scrollDOM.scrollHeight;
    }
    catch (error) {
        setTimeout(function () {
            scrollIntoLast(currentTry + 1);
        }, 500 * currentTry);
    }
};

/**
 * pubSub is used instead of messagesDispatcher to avoid redundantly calling
 * because this useSendMultipleFilesMessage is used in the Channel and Thread both
 */
var useSendMultipleFilesMessage = function (_a, _b) {
    var currentChannel = _a.currentChannel, onBeforeSendMultipleFilesMessage = _a.onBeforeSendMultipleFilesMessage, publishingModules = _a.publishingModules;
    var logger = _b.logger, pubSub = _b.pubSub, scrollRef = _b.scrollRef;
    var sendMessage = React.useCallback(function (files, quoteMessage) {
        return new Promise(function (resolve, reject) {
            if (!currentChannel) {
                logger.warning('Channel: Sending MFm failed, because currentChannel is null.', { currentChannel: currentChannel });
                reject();
            }
            if (files.length <= 1) {
                logger.warning('Channel: Sending MFM failed, because there are no multiple files.', { files: files });
                reject();
            }
            var messageParams = {
                fileInfoList: files.map(function (file) { return ({
                    file: file,
                    fileName: file.name,
                    fileSize: file.size,
                    mimeType: file.type,
                }); }),
            };
            if (quoteMessage) {
                messageParams.isReplyToChannel = true;
                messageParams.parentMessageId = quoteMessage.messageId;
            }
            if (typeof onBeforeSendMultipleFilesMessage === 'function') {
                messageParams = onBeforeSendMultipleFilesMessage(files, quoteMessage);
            }
            logger.info('Channel: Start sending MFM', { messageParams: messageParams });
            try {
                currentChannel.sendMultipleFilesMessage(messageParams)
                    /**
                     * We don't operate the onFileUploaded event for now
                     * until we will add UI/UX for it
                     */
                    .onFileUploaded(function (requestId, index, uploadableFileInfo, error) {
                    logger.info('Channel: onFileUploaded during sending MFM', {
                        requestId: requestId,
                        index: index,
                        error: error,
                        uploadableFileInfo: uploadableFileInfo,
                    });
                    pubSub.publish(pubSub_topics.pubSubTopics.ON_FILE_INFO_UPLOADED, {
                        response: {
                            channelUrl: currentChannel.url,
                            requestId: requestId,
                            index: index,
                            uploadableFileInfo: uploadableFileInfo,
                            error: error,
                        },
                        publishingModules: publishingModules,
                    });
                })
                    .onPending(function (pendingMessage) {
                    logger.info('Channel: in progress of sending MFM', { pendingMessage: pendingMessage, fileInfoList: messageParams.fileInfoList });
                    pubSub.publish(pubSub_topics.pubSubTopics.SEND_MESSAGE_START, {
                        message: pendingMessage,
                        channel: currentChannel,
                        publishingModules: publishingModules,
                    });
                    // We need this delay because rendering MFM takes time due to large image files.
                    setTimeout(function () {
                        if (scrollRef && pubSub_topics.shouldPubSubPublishToChannel(publishingModules)) {
                            utils.scrollIntoLast(0, scrollRef);
                        }
                        if (pubSub_topics.shouldPubSubPublishToThread(publishingModules)) {
                            scrollIntoLast(0);
                        }
                    }, 100);
                })
                    .onFailed(function (error, failedMessage) {
                    logger.error('Channel: Sending MFM failed.', { error: error, failedMessage: failedMessage });
                    pubSub.publish(pubSub_topics.pubSubTopics.SEND_MESSAGE_FAILED, {
                        channel: currentChannel,
                        message: failedMessage,
                        publishingModules: publishingModules,
                    });
                    reject(error);
                })
                    .onSucceeded(function (succeededMessage) {
                    logger.info('Channel: Sending voice message success!', { succeededMessage: succeededMessage });
                    pubSub.publish(pubSub_topics.pubSubTopics.SEND_FILE_MESSAGE, {
                        channel: currentChannel,
                        message: succeededMessage,
                        publishingModules: publishingModules,
                    });
                    // We need this delay because rendering MFM takes time due to large image files.
                    setTimeout(function () {
                        if (scrollRef && pubSub_topics.shouldPubSubPublishToChannel(publishingModules)) {
                            utils.scrollIntoLast(0, scrollRef);
                        }
                        if (pubSub_topics.shouldPubSubPublishToThread(publishingModules)) {
                            scrollIntoLast(0);
                        }
                    }, 100);
                    resolve(succeededMessage);
                });
            }
            catch (error) {
                logger.error('Channel: Sending MFM failed.', { error: error });
                reject(error);
            }
        });
    }, [
        currentChannel,
        onBeforeSendMultipleFilesMessage,
        publishingModules,
    ]);
    return [sendMessage];
};

exports.compareIds = compareIds;
exports.compareMessagesForGrouping = compareMessagesForGrouping;
exports.getNicknamesMapFromMembers = getNicknamesMapFromMembers;
exports.getParentMessageFrom = getParentMessageFrom;
exports.isAboutSame = isAboutSame;
exports.scrollIntoLast = scrollIntoLast;
exports.useSendMultipleFilesMessage = useSendMultipleFilesMessage;
//# sourceMappingURL=bundle-tFuTz5CT.js.map
