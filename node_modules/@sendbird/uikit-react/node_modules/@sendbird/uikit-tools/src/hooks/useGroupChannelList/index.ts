import { useEffect, useRef } from 'react';

import type SendbirdChat from '@sendbird/chat';
import type { BaseChannel } from '@sendbird/chat';
import type { GroupChannelCollection } from '@sendbird/chat/groupChannel';
import {
  GroupChannelEventSource,
  GroupChannelFilter,
  GroupChannelListOrder,
  GroupChannelModule,
} from '@sendbird/chat/groupChannel';
import type { ModuleNamespaces } from '@sendbird/chat/lib/__definition';

import { premiumFeatures } from '../../constants/premiumFeatures.js';
import { useAsyncEffect } from '../useAsyncEffect.js';
import { useGroupChannelHandler } from '../useGroupChannelHandler.js';
import { usePreservedCallback } from '../usePreservedCallback.js';
import { useGroupChannelListReducer } from './reducer.js';

type UseGroupChannelListOptions = {
  collectionCreator?: () => GroupChannelCollection;
  markAsDelivered?: (channels: BaseChannel[]) => void;
};

type SendbirdChatSDK = SendbirdChat & ModuleNamespaces<[GroupChannelModule]>;

const createGroupChannelListCollection = (
  sdk: SendbirdChatSDK,
  collectionCreator: UseGroupChannelListOptions['collectionCreator'],
) => {
  const passedCollection = collectionCreator?.();
  if (passedCollection) return passedCollection;

  const filter = new GroupChannelFilter();
  filter.includeEmpty = false;

  return sdk.groupChannel.createGroupChannelCollection({
    filter,
    limit: 20,
    order: GroupChannelListOrder.LATEST_LAST_MESSAGE,
  });
};

export const useGroupChanelList = (sdk: SendbirdChatSDK, options: UseGroupChannelListOptions) => {
  const deliveryReceiptEnabled = Boolean(sdk.appInfo?.premiumFeatureList?.includes(premiumFeatures.delivery_receipt));
  const collectionRef = useRef<GroupChannelCollection>();

  const {
    initialized,
    groupChannels,
    refreshing,
    appendChannels,
    deleteChannels,
    updateRefreshing,
    updateInitialized,
  } = useGroupChannelListReducer();

  const updateChannelsAndMarkAsDelivered = (
    shouldMarkAsDelivered: boolean,
    source?: GroupChannelEventSource,
    updatedChannels?: BaseChannel[],
  ) => {
    const channels = collectionRef.current?.channels ?? [];
    appendChannels(channels, true);

    if (shouldMarkAsDelivered && deliveryReceiptEnabled) {
      switch (source) {
        case GroupChannelEventSource.EVENT_MESSAGE_RECEIVED:
        case GroupChannelEventSource.EVENT_MESSAGE_SENT:
        case GroupChannelEventSource.SYNC_CHANNEL_BACKGROUND:
        case GroupChannelEventSource.SYNC_CHANNEL_CHANGELOGS:
        case undefined:
          options.markAsDelivered?.(updatedChannels ?? channels);
          break;
      }
    }
  };

  const init = usePreservedCallback(async (uid?: string) => {
    if (collectionRef.current) collectionRef.current?.dispose();

    if (uid) {
      collectionRef.current = createGroupChannelListCollection(sdk, options?.collectionCreator);

      collectionRef.current?.setGroupChannelCollectionHandler({
        onChannelsAdded: (context, channels) => {
          updateChannelsAndMarkAsDelivered(true, context.source, channels);
        },
        onChannelsUpdated: (context, channels) => {
          updateChannelsAndMarkAsDelivered(true, context.source, channels);
        },
        onChannelsDeleted: () => {
          updateChannelsAndMarkAsDelivered(false);
        },
      });

      if (collectionRef.current?.hasMore) {
        await collectionRef.current?.loadMore();
        updateChannelsAndMarkAsDelivered(true);
      }
    }
  });

  useEffect(() => {
    return () => {
      if (collectionRef.current) collectionRef.current?.dispose();
    };
  }, []);

  useAsyncEffect(async () => {
    updateInitialized(false);
    await init(sdk.currentUser?.userId);
    updateInitialized(true);
  }, [sdk, sdk.currentUser]);

  useGroupChannelHandler(sdk, {
    onUserBanned: (channel, user) => {
      const isMe = user.userId === sdk.currentUser?.userId;
      if (isMe) deleteChannels([channel.url]);
      else updateChannelsAndMarkAsDelivered(false);
    },
  });

  const refresh = usePreservedCallback(async () => {
    updateRefreshing(true);
    await init(sdk.currentUser?.userId);
    updateRefreshing(false);
  });

  const loadMore = usePreservedCallback(async () => {
    if (collectionRef.current?.hasMore) {
      await collectionRef.current?.loadMore();
      updateChannelsAndMarkAsDelivered(true);
    }
  });

  return {
    /**
     * Initializing state, only available on first render
     * */
    initialized,

    /**
     * Get group channels state
     * */
    groupChannels,

    /**
     * Refresh, clear and reload messages from latest
     * @return {Promise<void>}
     * */
    refresh,

    /**
     * Refreshing state, status is changes when the refresh is called.
     * */
    refreshing,

    /**
     * Fetch more channels to state
     * @return {Promise<void>}
     * */
    loadMore,
  };
};
